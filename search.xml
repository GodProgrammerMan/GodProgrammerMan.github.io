<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cpolar安装部署和使用（最详细）windows</title>
      <link href="/posts/8c53d709.html"/>
      <url>/posts/8c53d709.html</url>
      
        <content type="html"><![CDATA[<p>Cpolar 内网穿透介绍<br>Cpolar 是一个内网穿透工具，可以将本地服务暴露给外网用户访问。它通过映射本地端口，使得外部用户可以通过公共 URL 访问本地服务。以下是 Cpolar 的安装部署和使用的详细步骤。</p><h1 id="安装-Cpolar"><a href="#安装-Cpolar" class="headerlink" title="安装 Cpolar"></a>安装 Cpolar</h1><ul><li>访问 Cpolar 官网，下载适用于 Windows 的安装包，<a href="https://dashboard.cpolar.com/get-started">下载地址</a>登录后下载。</li><li>双击安装包，按照提示完成安装。</li><li>安装完成后，可以通过以下步骤启动 Cpolar：</li><li>打开命令提示符（cmd）。<br>输入 cpolar authtoken your-authtoken 将你的 Cpolar 账户授权给该设备。<br>输入 cpolar start 启动 Cpolar。</li></ul><h1 id="Cpolar-基本使用"><a href="#Cpolar-基本使用" class="headerlink" title="Cpolar 基本使用"></a>Cpolar 基本使用</h1><p>Cpolar 安装完成后，你可以使用它来将本地服务暴露给外网。运行后有个管理 Cpolar 隧道的地址 <a href="http://localhost:9200/%E8%AE%BF%E9%97%AE">http://localhost:9200/访问</a> Web 管理界面，使用你在 Cpolar 官网注册的账号登录。<br>例如开放 8080 端口，创建隧道<br><img src="https://image.imlzx.cn/blog/1724312754962.jpg" alt="创建隧道"><br>点击创建后再在线隧道列表就可以查看，外网地址：<br><a href="https://4a328643.r24.cpolar.top/">https://4a328643.r24.cpolar.top</a><br><img src="https://image.imlzx.cn/blog/1724312894691.jpg" alt="查看外网地址"></p>]]></content>
      
      
      <categories>
          
          <category> 开发生涯 </category>
          
          <category> Cpolar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网穿透 </tag>
            
            <tag> 本地服务外网暴露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现微信公众号扫码登录全过程（最详细）</title>
      <link href="/posts/55dccea6.html"/>
      <url>/posts/55dccea6.html</url>
      
        <content type="html"><![CDATA[<p>TOC(真心顶不住微信公众号开发文档的乱并且刚接触的开发者绝对一头雾水，决心编写，防止更多人跳坑！)</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>注册并配置微信公众号，获取 AppID 和 AppSecret。<br>配置开发者模式，设置服务器 URL 和 Token。（这一步以下会细讲）</p><h1 id="认证的公众号"><a href="#认证的公众号" class="headerlink" title="认证的公众号"></a>认证的公众号</h1><p>认证的公众号一年年费 300RMB，可以拥有“生成带参数的二维码”这一项接口权限，以及支付借口权限等具体可以去<a href="https://mp.weixin.qq.com/advanced/advanced?action=table&token=1190629242&lang=zh_CN">官方文档</a>登录后查看 “设置与开发”-》“接口权限”<br><img src="https://image.imlzx.cn/blog/6905749f60a8edb7a4ad12ecac1601b.png#pic_center" alt="认证号扫描登录流程图"></p><h2 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a>配置准备</h2><p>在 springboot 中 application.yml 配置微信公众号配置，appid、secret、token、aesKey，以及回调的接口 callback</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wx:</span></span><br><span class="line">  <span class="attr">mp:</span></span><br><span class="line">    <span class="attr">callback:</span></span><br><span class="line">    <span class="attr">configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">appId:</span> <span class="comment"># 第一个公众号的appid</span></span><br><span class="line">        <span class="attr">secret:</span> <span class="comment"># 公众号的appsecret</span></span><br><span class="line">        <span class="attr">token:</span> <span class="comment"># 接口配置里的Token值</span></span><br><span class="line">        <span class="attr">aesKey:</span> <span class="comment"># 接口配置里的EncodingAESKey值</span></span><br></pre></td></tr></table></figure><p>在 pom.xml 添加微信公众号开发的架包（或者自己写也可省了略）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.binarywang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>weixin-java-mp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="初始化-WxMpService"><a href="#初始化-WxMpService" class="headerlink" title="初始化 WxMpService"></a>初始化 WxMpService</h2><p>在配置类中初始化 WxMpService 类的方法返回 server 注入 Bean 中，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WxMpService <span class="title function_">wxMpService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;WxMpProperties.MpConfig&gt; configs = <span class="built_in">this</span>.properties.getConfigs();<span class="comment">//这里是获取application.yml配置信息，可以自己写方法获取</span></span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;没有配置微信公众号信息！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">WxMpService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WxMpServiceImpl</span>();</span><br><span class="line">    service.setMultiConfigStorages(configs</span><br><span class="line">            .stream().map(a -&gt; &#123;</span><br><span class="line">                WxMpDefaultConfigImpl configStorage;</span><br><span class="line">                configStorage = <span class="keyword">new</span> <span class="title class_">WxMpDefaultConfigImpl</span>();</span><br><span class="line">                configStorage.setAppId(a.getAppId());</span><br><span class="line">                configStorage.setSecret(a.getSecret());</span><br><span class="line">                configStorage.setToken(a.getToken());</span><br><span class="line">                configStorage.setAesKey(a.getAesKey());</span><br><span class="line">                <span class="keyword">return</span> configStorage;</span><br><span class="line">            &#125;).collect(Collectors.toMap(WxMpDefaultConfigImpl::getAppId, a -&gt; a, (o, n) -&gt; o)));</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p>可以使用 Cpolar Web UI 来做内网穿透进行测试，具体安装和设置可以在本站搜索“Cpolar 内网穿透”，没有的只能发布自己服务器进行 url 配置</p><ol><li>首先先在微信公众号填写服务器配置<br><img src="https://image.imlzx.cn/blog/f934a41751a1e00f61b9c59b22ebc43.jpg#pic_center" alt="服务器配置"><div class="note warning modern"><p>服务器地址(URL)一定要外网能访问，并且验证签名后返回 echostr，服务器配置的 token 和公众号的 token 要一致，这样才能在公众号上配置成功</p></div><div class="note warning modern"><p>配置完后一定要启用，不然无法生效</p></div>验证代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 微信认证配置接口</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> signature</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> timestamp</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> nonce</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> echostr</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@GetMapping(value = &quot;/authGet&quot;, produces = &quot;text/plain;charset=utf-8&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">authGet</span><span class="params">(<span class="meta">@RequestParam(name = &quot;signature&quot;, required = false)</span> String signature, <span class="meta">@RequestParam(name = &quot;timestamp&quot;, required = false)</span> String timestamp, <span class="meta">@RequestParam(name = &quot;nonce&quot;, required = false)</span> String nonce, <span class="meta">@RequestParam(name = &quot;echostr&quot;, required = false)</span> String echostr)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isAnyBlank(signature, timestamp, nonce, echostr)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;请求参数非法，请核实!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (wxService.checkSignature(timestamp, nonce, signature)) &#123;</span><br><span class="line">          <span class="keyword">return</span> echostr;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;非法请求&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>生成和请求一张带参数的二维码，返回给前端扫码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求微信接口，获取登录码地址</span></span><br><span class="line"><span class="type">WxMpQrCodeTicket</span> <span class="variable">wxMpQrCodeTicket</span> <span class="operator">=</span> wxMpService.getQrcodeService().qrCodeCreateTmpTicket(code, (<span class="type">int</span>) EXPIRE_TIME.getSeconds());<span class="comment">//code为携带的参数，(int) EXPIRE_TIME.getSeconds()为过期时间</span></span><br></pre></td></tr></table></figure><ol start="3"><li>扫码后，微信回调服务器接口；<br>有两种情况 1.如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值关注事件推送给开发者。 2.如果用户已经关注公众号，在用户扫描后会自动进入会话，微信也会将带场景值扫描事件推送给开发者。<br>post 的方式推送事件：1、事件推送将会推送给公众号在公众平台官网开发者中心设置的服务地址中 2、如果公众号已将账号管理权限集（因为该接口权限从属于账号管理权限集）授权给第三方平台，那么将由第三方平台代公众号接收事件推送，具体是推送到第三方平台的公众号消息与事件接收 URL</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> wxMpXmlMessage.getFromUser();</span><br><span class="line"> <span class="type">Integer</span> <span class="variable">loginCode</span> <span class="operator">=</span> Integer.parseInt(getEventKey(wxMpXmlMessage));</span><br><span class="line"> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDao.getUserByOpenId(openid);  <span class="comment">//  根据openid获取用户</span></span><br><span class="line"> <span class="comment">//如果已经注册,直接登录成功</span></span><br><span class="line"> <span class="keyword">if</span> (Objects.nonNull(user) &amp;&amp; StringUtils.isNotEmpty(user.getAvatar())) &#123;</span><br><span class="line">     ...返回前端更新登录状态等逻辑操作</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//user为空先注册,手动生成,以保存uid</span></span><br><span class="line"> <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">    ...先根据openid进行用户注册，即可</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//在redis中保存openid和场景code的关系，后续才能通知到前端,旧版数据没有清除,这里设置了过期时间</span></span><br><span class="line"> RedisUtils.set(RedisKey.getKey(RedisKey.OPEN_ID_STRING, openid), loginCode, <span class="number">60</span>, TimeUnit.MINUTES);</span><br><span class="line"> <span class="comment">//授权流程,给用户发送授权消息，并且异步通知前端扫码成功,等待授权</span></span><br><span class="line"> ...&#123;返回前端逻辑&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//URL为回调地址</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">skipUrl</span> <span class="operator">=</span> String.format(URL, wxMpService.getWxMpConfigStorage().getAppId(), URLEncoder.encode(callback + <span class="string">&quot;/wx/portal/public/callBack&quot;</span>));</span><br><span class="line"> WxMpXmlOutMessage.TEXT().build();</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TextBuilder</span>().build(<span class="string">&quot;请点击链接授权：&lt;a href=\&quot;&quot;</span> + skipUrl + <span class="string">&quot;\&quot;&gt;登录&lt;/a&gt;&quot;</span>, wxMpXmlMessage, wxMpService);<span class="comment">//给发送者当前openid的微信公众上发送登录消息</span></span><br></pre></td></tr></table></figure><p>回调接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> wxMpXmlMessage.getFromUser();</span><br><span class="line"> <span class="type">Integer</span> <span class="variable">loginCode</span> <span class="operator">=</span> Integer.parseInt(getEventKey(wxMpXmlMessage));</span><br><span class="line"> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDao.getUserByOpenId(openid);  <span class="comment">//  根据openid获取用户</span></span><br><span class="line"> <span class="comment">//如果已经注册,直接登录成功</span></span><br><span class="line"> <span class="keyword">if</span> (Objects.nonNull(user) &amp;&amp; StringUtils.isNotEmpty(user.getAvatar())) &#123;</span><br><span class="line">     ...返回前端更新登录状态等逻辑操作</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//user为空先注册,手动生成,以保存uid</span></span><br><span class="line"> <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">    ...先根据openid进行用户注册，即可</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//在redis中保存openid和场景code的关系，后续才能通知到前端,旧版数据没有清除,这里设置了过期时间</span></span><br><span class="line"> RedisUtils.set(RedisKey.getKey(RedisKey.OPEN_ID_STRING, openid), loginCode, <span class="number">60</span>, TimeUnit.MINUTES);</span><br><span class="line"> <span class="comment">//授权流程,给用户发送授权消息，并且异步通知前端扫码成功,等待授权</span></span><br><span class="line"> ...&#123;返回前端逻辑&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//URL为回调地址</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">skipUrl</span> <span class="operator">=</span> String.format(URL, wxMpService.getWxMpConfigStorage().getAppId(), URLEncoder.encode(callback + <span class="string">&quot;/wx/portal/public/callBack&quot;</span>));</span><br><span class="line"> WxMpXmlOutMessage.TEXT().build();</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TextBuilder</span>().build(<span class="string">&quot;请点击链接授权：&lt;a href=\&quot;&quot;</span> + skipUrl + <span class="string">&quot;\&quot;&gt;登录&lt;/a&gt;&quot;</span>, wxMpXmlMessage, wxMpService);<span class="comment">//给发送者当前openid的微信公众上发送登录消息</span></span><br></pre></td></tr></table></figure><h1 id="未认证公众号"><a href="#未认证公众号" class="headerlink" title="未认证公众号"></a>未认证公众号</h1><p>未认证的公众号的步骤基本差不多，差别就是没有生成带参数的二维码的权限，通过“接收普通消息”和“接收事件推送”这两个接口权限去验证 openid 用户。主要两种方式：1.前端提供参数扫码关注公众号后回复参数校验通过。2.关注公众号后开发者推送参数校验，在前端填写后登录。实现方式基本一致，就不分开讲述。这里主要讲前端提供参数扫码关注公众号后回复参数校验通过。</p><h2 id="前端提供参数扫码关注公众号后回复参数校验通过"><a href="#前端提供参数扫码关注公众号后回复参数校验通过" class="headerlink" title="前端提供参数扫码关注公众号后回复参数校验通过"></a>前端提供参数扫码关注公众号后回复参数校验通过</h2><p>首先需要做的步骤和上述差不多</p><h3 id="配置准备-1"><a href="#配置准备-1" class="headerlink" title="配置准备"></a>配置准备</h3><p>在 springboot 中 application.yml 配置微信公众号配置，appid、secret、token、aesKey，以及回调的接口 callback</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wx:</span></span><br><span class="line">  <span class="attr">mp:</span></span><br><span class="line">    <span class="attr">callback:</span></span><br><span class="line">    <span class="attr">configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">appId:</span> <span class="comment"># 第一个公众号的appid</span></span><br><span class="line">        <span class="attr">secret:</span> <span class="comment"># 公众号的appsecret</span></span><br><span class="line">        <span class="attr">token:</span> <span class="comment"># 接口配置里的Token值</span></span><br><span class="line">        <span class="attr">aesKey:</span> <span class="comment"># 接口配置里的EncodingAESKey值</span></span><br></pre></td></tr></table></figure><p>在 pom.xml 添加微信公众号开发的架包（或者自己写也可省了略）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.binarywang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>weixin-java-mp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="初始化-WxMpService-1"><a href="#初始化-WxMpService-1" class="headerlink" title="初始化 WxMpService"></a>初始化 WxMpService</h3><p>在配置类中初始化 WxMpService 类的方法返回 server 注入 Bean 中，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WxMpService <span class="title function_">wxMpService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;WxMpProperties.MpConfig&gt; configs = <span class="built_in">this</span>.properties.getConfigs();<span class="comment">//这里是获取application.yml配置信息，可以自己写方法获取</span></span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;没有配置微信公众号信息！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">WxMpService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WxMpServiceImpl</span>();</span><br><span class="line">    service.setMultiConfigStorages(configs</span><br><span class="line">            .stream().map(a -&gt; &#123;</span><br><span class="line">                WxMpDefaultConfigImpl configStorage;</span><br><span class="line">                configStorage = <span class="keyword">new</span> <span class="title class_">WxMpDefaultConfigImpl</span>();</span><br><span class="line">                configStorage.setAppId(a.getAppId());</span><br><span class="line">                configStorage.setSecret(a.getSecret());</span><br><span class="line">                configStorage.setToken(a.getToken());</span><br><span class="line">                configStorage.setAesKey(a.getAesKey());</span><br><span class="line">                <span class="keyword">return</span> configStorage;</span><br><span class="line">            &#125;).collect(Collectors.toMap(WxMpDefaultConfigImpl::getAppId, a -&gt; a, (o, n) -&gt; o)));</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h3><p>可以使用 Cpolar Web UI 来做内网穿透进行测试，具体安装和设置可以在本站搜索“Cpolar 内网穿透”，没有的只能发布自己服务器进行 url 配置</p><ol><li>首先先在微信公众号填写服务器配置<br><img src="https://image.imlzx.cn/blog/f934a41751a1e00f61b9c59b22ebc43.jpg#pic_center" alt="服务器配置"><div class="note warning modern"><p>服务器地址(URL)一定要外网能访问，并且验证签名后返回 echostr，服务器配置的 token 和公众号的 token 要一致，这样才能在公众号上配置成功</p></div><div class="note warning modern"><p>配置完后一定要启用，不然无法生效</p></div>验证代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 微信认证配置接口</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> signature</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> timestamp</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> nonce</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> echostr</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@GetMapping(value = &quot;/authGet&quot;, produces = &quot;text/plain;charset=utf-8&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">authGet</span><span class="params">(<span class="meta">@RequestParam(name = &quot;signature&quot;, required = false)</span> String signature, <span class="meta">@RequestParam(name = &quot;timestamp&quot;, required = false)</span> String timestamp, <span class="meta">@RequestParam(name = &quot;nonce&quot;, required = false)</span> String nonce, <span class="meta">@RequestParam(name = &quot;echostr&quot;, required = false)</span> String echostr)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isAnyBlank(signature, timestamp, nonce, echostr)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;请求参数非法，请核实!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (wxService.checkSignature(timestamp, nonce, signature)) &#123;</span><br><span class="line">          <span class="keyword">return</span> echostr;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;非法请求&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>再写一个接口 authGet，请求方式为 Post</li></ol><p>推送的请求包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[FromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[event]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Event</span>&gt;</span>&lt;![CDATA[subscribe]]&gt;<span class="tag">&lt;/<span class="name">Event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用户关注&#x2F;取消公众号。发送消息给公众号，都进这个方法，根据消息去处理登录逻辑即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/authGet&quot;, produces = &quot;application/xml; charset=UTF-8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">wxtoMessage</span><span class="params">(<span class="meta">@RequestBody</span> String xmlData)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">WxMpXmlMessage</span> <span class="variable">inMessage</span> <span class="operator">=</span> WxMpXmlMessage.fromXml(xmlData);</span><br><span class="line">   <span class="comment">// 处理二维码扫描事件</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="string">&quot;event&quot;</span>.equals(inMessage.getMsgType()) &amp;&amp; (<span class="string">&quot;SCAN&quot;</span>.equals(inMessage.getEvent()) || <span class="string">&quot;subscribe&quot;</span>.equals(inMessage.getEvent()))) &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">openId</span> <span class="operator">=</span> inMessage.getFromUserName(); <span class="comment">// 获取openid</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">msgType</span> <span class="operator">=</span> inMessage.getMsgType(); <span class="comment">// 获取用户的动作</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//处理关注的动作</span></span><br><span class="line">       <span class="keyword">if</span>(msgType为subscribe)&#123;<span class="comment">//处理关注的逻辑</span></span><br><span class="line">           <span class="comment">//1.拿到openid去判断如果用户已经注册，也可以向用户发去填写验证码的逻辑</span></span><br><span class="line">           <span class="keyword">if</span>(用户存在)&#123;</span><br><span class="line"></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">//2.用户不存在，则注册用户，并向用户索要验证码的逻辑</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;<span class="comment">//处理取消关注的逻辑</span></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//判断用户从公众号发来的验证码消息进行对比，如果正确则处理登录逻辑</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理其他消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发生涯 </category>
          
          <category> java </category>
          
          <category> 微信公众号开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信公众号开发 </tag>
            
            <tag> 扫描登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ集群部署</title>
      <link href="/posts/63d6a691.html"/>
      <url>/posts/63d6a691.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ的安装和配置</title>
      <link href="/posts/9d0b4d7.html"/>
      <url>/posts/9d0b4d7.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、RocketMQ-的介绍"><a href="#一、RocketMQ-的介绍" class="headerlink" title="一、RocketMQ 的介绍"></a>一、RocketMQ 的介绍</h2><ol><li><p>RocketMQ</p><p>Apache RocketMQ 是一款低延迟、高并发、高可用、高可靠的分布式消息中间件。消息队列 RocketMQ 可为分布式应用系统提供异步解耦和削峰填谷的能力，同时也具备互联网应用所需的海量消息堆积、高吞吐、可靠重试等特性。</p></li><li><p>RocketMQ 概念</p><ul><li>Producer（生产者）：<br>生产者负责生成并发送消息到消息队列。通常，生产者是业务系统的组件，例如订单处理系统生成订单消息并发送到队列中。</li><li>Consumer（消费者）：<br>消费者从消息队列中获取并处理消息。消费者可以是多个，并且可以分为两种类型：<br>Push Consumer：主动接收消息。<br>Pull Consumer：主动从队列中拉取消息。</li><li>Topic（主题）：<br>Topic 是消息的逻辑分类，每个 Topic 代表一个消息类别。生产者将消息发送到特定的 Topic，消费者订阅并消费特定 Topic 下的消息。</li><li>Message（消息）：<br>消息是 RocketMQ 传输的最小单位。消息体可以是任意的字节数组，通常为 JSON、XML 或其他序列化格式。</li><li>Broker（消息代理）：<br>Broker 是消息中间件的核心组件，负责接收、存储、转发消息。Broker 通过 Topic 和队列管理消息，并确保消息的可靠传输。</li><li>NameServer：<br>NameServer 是轻量级的服务发现和路由管理组件，Broker 和生产者、消费者通过它来发现彼此的地址，并完成消息的路由。</li><li>Queue（队列）：<br>每个 Topic 可以有多个队列（Partition），消息会根据一定的策略分发到不同的队列中。多个消费者可以并行消费同一个 Topic 下的不同队列，提高吞吐量。</li><li>Tag（标签）：<br>Tag 是用于对消息进行进一步分类的标记，帮助消费者过滤消息。例如，在一个 Topic 下，可以根据不同的标签过滤出特定类型的消息进行消费。</li><li>Order Message（顺序消息）：<br>顺序消息是 RocketMQ 提供的一种消息投递方式，保证同一生产者发送的消息按顺序到达同一消费者。</li><li>Transactional Message（事务消息）：<br>RocketMQ 支持分布式事务消息。生产者可以发送半消息（half message），消费者暂时不会消费，直到生产者确认事务提交，RocketMQ 才会将消息推送给消费者。</li></ul></li><li><p>为什么 RocketMQ</p><p>在阿里孕育 RocketMQ 的雏形时期，我们将其用于异步通信、搜索、社交网络活动流、数据管道，贸易流程中。随着我们的贸易业务吞吐量的上升，源自我们的消息传递集群的压力也变得紧迫。<br>根据我们的研究，随着队列和虚拟主题使用的增加，ActiveMQ IO 模块达到了一个瓶颈。我们尽力通过节流、断路器或降级来解决这个问题，但效果并不理想。于是我们尝试了流行的消息传递解决方案 Kafka。不幸的是，Kafka 不能满足我们的要求，其尤其表现在低延迟和高可靠性方面，详见下文。在这种情况下，我们决定发明一个新的消息传递引擎来处理更广泛的消息用例，覆盖从传统的 pub&#x2F;sub 场景到高容量的实时零误差的交易系统。<br>Apache RocketMQ 自诞生以来，因其架构简单、业务功能丰富、具备极强可扩展性等特点被众多企业开发者以及云厂商广泛采用。历经十余年的大规模场景打磨，RocketMQ 已经成为业内共识的金融级可靠业务消息首选方案，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景。</p></li></ol><h2 id="二、RocketMQ-的安装"><a href="#二、RocketMQ-的安装" class="headerlink" title="二、RocketMQ 的安装"></a>二、RocketMQ 的安装</h2><ol><li><p>本地部署<br><a href="https://rocketmq.apache.org/zh/download">下载地址</a></p><ul><li><p>Window<br>下载完后解压到自定义目录，MQ 解压路径\rocketmq-all-5.3.0-bin-release；</p><div class="note warning modern"><p>注意 （Windows11 系统解压路径不要出现空格）</p></div><div class="note warning modern"><p>注意 （ 同时安装的 jdk 路径也不能有空格，不然会提示启动 NameServer 会出现“此时不应有 XXXX”XX:JDK 路径）</p></div><p>配置环境变量<br>配置环境变量，变量名：ROCKETMQ_HOME 变量值：（你的解压路径）；path 后追加;%ROCKETMQ_HOME%\bin<br><img src="https://image.imlzx.cn/blog/1723885894667.jpg#pic_center" alt="系统环境变量"><br>启动 NameServer<br>可启动 cmd 命令执行进入至‘安装的 MQ 目录\bin’下，执行命令‘start mqnamesrv.cmd’，启动 NAMESERVER。成功后会弹出提示框；<br>或直接使用 mqnamesrv.cmd 双击运行</p><p>&#x2F;&#x2F;RockerMQ 配置 Broker 密码<br>在 rocketMQ 安装目录下的 conf 文件夹-broker.conf，设置<br>brokerPermission&#x3D;password &#x2F;&#x2F;开启密码</p><p>plainTextAccessKey&#x3D;root &#x2F;&#x2F;设置账户名<br>plainTextSecretKey&#x3D;123456 &#x2F;&#x2F;设置密码</p><p>启动 Broker<br>在安装目录 bin 下 cmd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">start mqbroker.cmd -n localhost:9876 autoCreateTopicEnable=<span class="literal">true</span></span></span><br></pre></td></tr></table></figure><p>进入至‘MQ 文件夹\bin’下,修改 runbroker.cmd 中 JVM 占用内存大小<br><img src="https://image.imlzx.cn/blog/172sadq5552.png#pic_center" alt="修改JVM内存"><br>启动后窗口不可关闭。也可以看设置服务启动。</p><p>rocketmq 控制台安装及配置<br><a href="https://rocketmq.apache.org/zh/download/#rocketmq-dashboard">下载地址</a><br>解压后，修改源码中 src 里面的 application.properties 配置文件 端口号：19876（防止端口冲突 9876 为 mq 端口）<br>同时添加密码检验，如果没有设置密码则不用修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#set the accessKey and secretKey if you used acl</span><br><span class="line">rocketmq.config.accessKey=root</span><br><span class="line">rocketmq.config.secretKey=123456</span><br><span class="line">rocketmq.config.useTLS=true</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入解压根目录执行 mvn 打包命令</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">    mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>生成的 target 下将有 rocketmq-dashboard-1.0.0.jar 包。<br>RocketMQ 注册为 Windows 服务<br><a href="https://nssm.cc/download">下载地址</a><br><img src="https://image.imlzx.cn/blog/1723888661302.jpg#pic_center" alt="选中下载"></p><p>在 RocketMQ 目录上新建文件夹 admin，并将上述生成的 rocketmq-dashboard-1.0.0.jar 包放入其中</p><p>同时在根目录新建文件 start.bat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start .\bin\mqnamesrv.cmd</span><br><span class="line">start .\bin\mqbroker.cmd -n localhost:9876 autoCreateTopicEnable=true</span><br><span class="line">java -jar .\admin\rocketmq-dashboard-1.0.0.jar</span><br></pre></td></tr></table></figure><p><img src="https://image.imlzx.cn/blog/1723889586087.jpg#pic_center" alt="文件目录"><br>nssm 下载后解压，选择相应的系统，并在目录上执行：nssm install RocketMQ<br>选择<br><img src="https://image.imlzx.cn/blog/1723889666610.jpg#pic_center" alt="添加window服务"><br>并确定即可启动服务</p><ul><li><p>Linux<br>这里以在 Linux 环境下利用社区 5.3.0 的源码包为例，介绍 RocketMQ 安装过程。<br>解压 5.3.0 的源码包并编译构建二进制可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip rocketmq-all-5.3.0-source-release.zip</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> rocketmq-all-5.3.0-source-release/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mvn -Prelease-all -DskipTests -Dspotbugs.skip=<span class="literal">true</span> clean install -U</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> distribution/target/rocketmq-5.3.0/rocketmq-5.3.0</span></span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 启动namesrv</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> sh bin/mqnamesrv &amp;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 验证namesrv是否启动成功</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span></span><br><span class="line">The Name Server boot success...</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Docker 部署 RocketMQ</p><ul><li><p>拉取 RocketMQ 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull apache/rocketmq:5.3.0</span><br></pre></td></tr></table></figure></li><li><p>创建容器共享网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create rocketmq</span><br></pre></td></tr></table></figure></li><li><p>启动 NameServer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 NameServer</span></span><br><span class="line">docker run -d --name rmqnamesrv -p 9876:9876 --network rocketmq apache/rocketmq:5.3.0 sh mqnamesrv</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证 NameServer 是否启动成功</span></span><br><span class="line">docker logs -f rmqnamesrv</span><br></pre></td></tr></table></figure></li><li><p>启动 Broker+Proxy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置 Broker 的IP地址</span></span><br><span class="line">echo &quot;brokerIP1=127.0.0.1&quot; &gt; broker.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Broker 和 Proxy</span></span><br><span class="line">docker run -d \</span><br><span class="line">--name rmqbroker \</span><br><span class="line">--network rocketmq \</span><br><span class="line">-p 10912:10912 -p 10911:10911 -p 10909:10909 \</span><br><span class="line">-p 8080:8080 -p 8081:8081 \</span><br><span class="line">-e &quot;NAMESRV_ADDR=rmqnamesrv:9876&quot; \</span><br><span class="line">-v ./broker.conf:/home/rocketmq/rocketmq-5.3.0/conf/broker.conf \</span><br><span class="line">apache/rocketmq:5.3.0 sh mqbroker --enable-proxy \</span><br><span class="line">-c /home/rocketmq/rocketmq-5.3.0/conf/broker.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证 Broker 是否启动成功</span></span><br><span class="line">docker exec -it rmqbroker bash -c &quot;tail -n 10 /home/rocketmq/logs/rocketmqlogs/proxy.log&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Docker Compose 部署 RocketMQ</p><ul><li>编写 docker-compose<br>为了快速启动并运行 RockerMQ 集群，您可以使用以下模板通过修改或添加环境部分中的配置来创建 docker-compose.yml 文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.8&#x27;</span><br><span class="line">services:</span><br><span class="line">namesrv:</span><br><span class="line">image: apache/rocketmq:5.3.0</span><br><span class="line">container_name: rmqnamesrv</span><br><span class="line">ports: - 9876:9876</span><br><span class="line">networks: - rocketmq</span><br><span class="line">command: sh mqnamesrv</span><br><span class="line">broker:</span><br><span class="line">image: apache/rocketmq:5.3.0</span><br><span class="line">container_name: rmqbroker</span><br><span class="line">ports: - 10909:10909 - 10911:10911 - 10912:10912</span><br><span class="line">environment: - NAMESRV_ADDR=rmqnamesrv:9876</span><br><span class="line">depends_on: - namesrv</span><br><span class="line">networks: - rocketmq</span><br><span class="line">command: sh mqbroker</span><br><span class="line">proxy:</span><br><span class="line">image: apache/rocketmq:5.3.0</span><br><span class="line">container_name: rmqproxy</span><br><span class="line">networks: - rocketmq</span><br><span class="line">depends_on: - broker - namesrv</span><br><span class="line">ports: - 8080:8080 - 8081:8081</span><br><span class="line">restart: on-failure</span><br><span class="line">environment: - NAMESRV_ADDR=rmqnamesrv:9876</span><br><span class="line">command: sh mqproxy</span><br><span class="line">networks:</span><br><span class="line">rocketmq:</span><br><span class="line">driver: bridge</span><br></pre></td></tr></table></figure><ul><li>启动 RocketMQ 集群<br>linux</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>window</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -p rockermq_project up -d</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、RocketMQ-的特点"><a href="#三、RocketMQ-的特点" class="headerlink" title="三、RocketMQ 的特点"></a>三、RocketMQ 的特点</h2><ul><li>高吞吐量：RocketMQ 通过队列和分布式架构支持大规模并发消息处理，适用于高吞吐量的场景。</li><li>低延迟：支持毫秒级的消息投递延迟，适合对时效性要求高的应用。</li><li>高可用性和持久性：通过多副本机制和日志文件存储，保证消息在异常情况下不丢失，并能够快速恢复。</li><li>消息的顺序性：支持消息按发送顺序消费，确保某些场景下的消息顺序不被打乱。</li><li>分布式事务支持：RocketMQ 提供的事务消息，可以保证分布式系统中的数据一致性。</li></ul><h2 id="四、RocketMQ-的场景"><a href="#四、RocketMQ-的场景" class="headerlink" title="四、RocketMQ 的场景"></a>四、RocketMQ 的场景</h2><ul><li>异步处理：例如订单处理系统，在订单生成后异步发送订单消息到消息队列，进行后续处理，如库存更新、通知等。</li><li>事件驱动架构：利用消息队列实现微服务之间的解耦，通过事件触发服务间的通信。</li><li>日志收集：在分布式系统中，消息队列可以用于日志的收集和聚合，方便后续分析和处理。</li><li>流量削峰填谷：在高并发场景中，消息队列可以用来削峰填谷，将请求平滑地分发到后端处理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发生涯 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 高可用 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团2024年春招第一场笔试【技术】-小美的平衡矩阵</title>
      <link href="/posts/9f3081ce.html"/>
      <url>/posts/9f3081ce.html</url>
      
        <content type="html"><![CDATA[<h2 id="平衡矩阵"><a href="#平衡矩阵" class="headerlink" title="平衡矩阵"></a>平衡矩阵</h2><p>小美拿到了一个 n∗n 的矩阵，其中每个元素是 0 或者 1。<br>小美认为一个矩形区域是完美的，当且仅当该区域内 0 的数量恰好等于 1 的数量。<br>现在，小美希望你回答有多少个 i∗i 的完美矩形区域。你需要回答 1≤i≤n 的所有答案。</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行输入一个正整数n，代表矩阵大小。</span><br><span class="line">接下来的n行，每行输入一个长度为n的 01 串，用来表示矩阵。</span><br><span class="line">1\leq n \leq 200</span><br></pre></td></tr></table></figure><h3 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出n行，第i行输出i*i的完美矩形区域的数量。</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">4</span><br><span class="line">1010</span><br><span class="line">0101</span><br><span class="line">1100</span><br><span class="line">0011</span><br><span class="line">输出例子：</span><br><span class="line">0</span><br><span class="line">7</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>前缀和计算：我们需要构建一个二维数组来保存从 (0,0) 到 (i,j) 的区域中 1 和 0 的数量之差。这样我们就可以通过矩形区域的差值来判断是否为完美矩形。</li><li>矩形枚举：通过枚举不同尺寸的矩形，检查每个矩形区域内 1 和 0 的数量是否相等。</li></ol><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerfectRectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        scanner.nextLine();  <span class="comment">// 读取换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                matrix[i][j] = line.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前缀和数组，存储1和0的差值</span></span><br><span class="line">        <span class="type">int</span>[][] diff = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算前缀和：diff[i][j] 表示从 (0,0) 到 (i-1,j-1) 的1和0的差值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">                diff[i][j] = diff[i - <span class="number">1</span>][j] + diff[i][j - <span class="number">1</span>] - diff[i - <span class="number">1</span>][j - <span class="number">1</span>] + val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算每个尺寸的完美矩形数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>; size &lt;= n; size++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> size; j &lt;= n; j++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> diff[i][j] - diff[i - size][j] - diff[i][j - size] + diff[i - size][j - size];</span><br><span class="line">                    <span class="keyword">if</span> (total == <span class="number">0</span>) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ol><li><p>前缀和差值矩阵 diff：diff[i][j] 表示从左上角到 (i-1, j-1) 的矩形区域中，1 和 0 的数量差值。我们使用 1 表示 1，使用 -1 表示 0，因此如果某个子矩形区域的差值为 0，说明这个区域内 1 和 0 的数量相等，即为一个完美矩形。</p></li><li><p>矩形枚举：对于每个尺寸 size 的矩形，我们遍历所有可能的起点 (i, j)，通过前缀和差值快速计算出矩形内的 1 和 0 的数量。如果差值为 0，则这个矩形为完美矩形。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发生涯 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GeoServer源码在eclipse上构建并在Docker部署发布</title>
      <link href="/posts/9f3089ce.html"/>
      <url>/posts/9f3089ce.html</url>
      
        <content type="html"><![CDATA[<h1 id="GeoServer-源码在-eclipse-上构建"><a href="#GeoServer-源码在-eclipse-上构建" class="headerlink" title="GeoServer 源码在 eclipse 上构建"></a>GeoServer 源码在 eclipse 上构建</h1><p>1.环境准备<br>安装 jdk，安装 Maven 2.下载源码<br><a href="https://geoserver.org/release/stable/,%E9%80%89%E6%8B%A9%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%EF%BC%8C%E8%A7%A3%E5%8E%8B%E5%B9%B6%E5%9C%A8src%E7%9B%AE%E5%BD%95%E4%B8%8Bcmd%E4%BD%BF%E7%94%A8Maven%E6%9E%84%E5%BB%BA">https://geoserver.org/release/stable/,选择源码下载，解压并在src目录下cmd使用Maven构建</a></p><p>3.构建<br>新版本尽量 java11 以上–环境变量改回原来 java8 的路径即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=true //清class文件，打包构建，跳过测试</span><br></pre></td></tr></table></figure><p>打开 cmd，切换到源码目录的 src 底下，写入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn eclipse:eclipse</span><br></pre></td></tr></table></figure><p>4.eclipse 导入源码<br>File→Import,</p><p>导入时候选择已经存在的工程：Existing Project into workspace</p><p>切换目录到已经部署好的 src 目录底下，单击【finish】即可</p><p>找到 gs-web-app 目录底下的 Start.java，右击【Run as】|【Java Application】</p><p>在浏览器输入地址：<br><a href="https://links.jianshu.com/go?to=http://localhost:8080/geoserver/web">http://localhost:8080/geoserver/web</a><br>一般默认登录账号为 admin，密码是 geoserver</p><p>正常来说，至此在 eclipse 中已经可以启动 geoserver 了。但是，我在处理时，引入工程后，有些工程是报错的：</p><p>Eclipse 中有一种叫做存取限制的机制，来防止你错误使用那些非共享的 API。通常来说，Eclipse 做的是对的，因为两点，我们不想要使用非共享 API 的，而且 Eclipse 知道什么是共享的和非共享的 API。但是有时我们想要使用非共享的 API，比如说用 gmail 来发送和接收邮件，要用到 SSL。这个就是非共享的 API。这时候我们就要更改一些设置了。<br>更改的步骤如下：<br>window-Preferences-java-compiler-Error&#x2F;Warning-Deprecated and restricted API-Forbidden reference 那里，设置成 Ignore 即可</p><h1 id="二次开发"><a href="#二次开发" class="headerlink" title="二次开发"></a>二次开发</h1><ol><li><p>源码导入到 eclipse 中</p></li><li><p>右键工程-export-web-war file</p></li><li><p>导出 war 文件放入 webapps 上并重启 tomcat 即可</p><p>上述如不行：</p><p>则需要在项目 src\web\app 下，运行 cmd：执行命令进行打包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -DskipTests</span><br></pre></td></tr></table></figure><p>重点，如要其他项目架包，则在 eclipse 中右键去到当前项目架包 src 下，删掉 target 文件，然后在文件路径栏下 cmd 运行 mvn 命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -DskipTests</span><br></pre></td></tr></table></figure><p>成功后在 target 找到当前项目架包 并替换在 tomcat 的 geoserver 下 lib 目录下即可</p></li></ol><h1 id="Docker-部署发布"><a href="#Docker-部署发布" class="headerlink" title="Docker 部署发布"></a>Docker 部署发布</h1><p>1.环境准备<br>已安装 Docker<br>在线安装命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">脚本安装</span><br><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br><span class="line">完毕</span><br><span class="line"></span><br><span class="line">rpm安装</span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line">完毕</span><br></pre></td></tr></table></figure><p>Docker 配置镜像加速器，使用阿里云加速器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://XXXX.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>个人加速地址登陆阿里云并在控制台中搜索“容器镜像服务 ACR“- “镜像加速“内有 2.创建 tomcat 镜像并将发布好 geoserver.war 文件放入 webapps<br>&#x2F;&#x2F;需要挂载配置文件 server.xml 和 web.xml、webapps、mapwebapps（为 geoserver）。后续需要配置 https 再进行证书路径配置或者可以放置 conf 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name tomcat -p 7078:7078 -e TZ=Asia/Shanghai   -v /usr/applin/tomcat/conf/server.xml:/usr/local/tomcat/conf/server.xml   -v /usr/applin/tomcat/conf/web.xml:/usr/local/tomcat/conf/web.xml   -v /usr/applin/tomcat/webapps:/usr/local/tomcat/webapps   -v /usr/applin/tomcat/logs:/usr/local/tomcat/logs -v /usr/applin/tomcat/cert:/usr/local/tomcat/cert --network lzx tomcat</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">          -d   后台运行</span><br><span class="line">          --name 容器名称为tomcat</span><br><span class="line">          -p 配置端口7078</span><br><span class="line">          -e TZ=Asia/Shanghai //配置时区</span><br><span class="line">          -v 本地挂载配置server.xml，需要配置端口</span><br><span class="line">          -v 本地挂载配置web.xml</span><br><span class="line">          -v 本地挂载配置logs  tomcat启动日志</span><br><span class="line">          -v 本地挂载配置webapps</span><br><span class="line">          --network 加入网络lzx</span><br><span class="line">无法挂载lib，只能先创建容器后再进行将jar复制到容器中。</span><br><span class="line">docker cp /usr/applin/tomcat/lib tomcat:/usr/local/tomcat</span><br><span class="line">*在使用原有镜像tomcat的lib中发现报错，而且本身也需要添加java-property-utils-1.9.jar和cors-filter-1.7.jar两个架包 *</span><br><span class="line"></span><br><span class="line">重新启动</span><br><span class="line">docker start tomcat</span><br><span class="line"></span><br><span class="line">进入容器：docker exec -it tomcat bash</span><br><span class="line"></span><br><span class="line">映像中的默认 Tomcat 环境为：</span><br><span class="line">CATALINA_BASE:   /usr/local/tomcat</span><br><span class="line">CATALINA_HOME:   /usr/local/tomcat</span><br><span class="line">CATALINA_TMPDIR: /usr/local/tomcat/temp</span><br><span class="line">JRE_HOME:        /usr</span><br><span class="line">CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar</span><br></pre></td></tr></table></figure><p>配置文件位于 “&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;conf&#x2F;“中。默认情况下，操作“&#x2F;manager&#x2F;html”Web 应用程序所需的“manager-gui”角色中不包含任何用户。如果要使用此应用，则必须在 中定义此类用户”tomcat-users.xml”。<br>3.geoserver 的数据 data 文件配置<br>在 geoserver\WEB-INF\web.xml 中找到 GEOSERVER_DATA_DIR，并将该节点的路径改为容器内，或者是挂载到 tomcat 上的 data 路径【方便迁移】，否则将默认 geoserver&#x2F;data 这个数据文件夹<br>顺便将 geoserver 部署至 tomcat</p><h1 id="使用镜像-Nginx-代理"><a href="#使用镜像-Nginx-代理" class="headerlink" title="使用镜像 Nginx 代理"></a>使用镜像 Nginx 代理</h1><p>1.Docker 创建 Nginx 镜像<br>使用本地挂载数据卷，方便编写配置和映射数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx -p 80:80  -p 8080:8080 -p 8081:8081 -p 8082:8082 -p 8083:8083 -p 8084:8084 -p 8085:8085 -v /usr/applin/nginx/webapp:/usr/share/nginx/html -v /usr/applin/nginx/nginx.conf:/etc/nginx/nginx.conf --network lzx nginx</span><br><span class="line"></span><br><span class="line">//启动nginx</span><br><span class="line">docker start nginx</span><br></pre></td></tr></table></figure><p>配置代理</p><pre><code>server &#123;    listen       80;    listen       [::]:80;    server_name  【自己域名或location或_】; location / &#123;    rewrite ^/$ /geoserver/ permanent;&#125;location /geoserver/ &#123;    proxy_pass http://tomcat:7078/geoserver/;    proxy_set_header Host $host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Forwarded-Proto $scheme;&#125;&#125;</code></pre><p>这里的 <a href="http://tomcat:7078/geoserver/;%E9%9C%80%E8%A6%81%E5%B0%86">http://tomcat:7078/geoserver/;需要将</a> nginx 和 tomcat 加入 Docker 创建的网桥 lzx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network create lzx</span><br><span class="line">docker network connect  nginx lzx</span><br><span class="line">docker network connect  tomcat lzx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Geoserver </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx优化</title>
      <link href="/posts/b15d8e56.html"/>
      <url>/posts/b15d8e56.html</url>
      
        <content type="html"><![CDATA[<p>在今天的文章中，我们将深入探讨 Nginx 的配置和优化技巧，帮助您更好地管理和提升 Web 服务器的性能。</p><p>Nginx 是一款高性能的 HTTP 和反向代理服务器，它以其出色的并发处理能力和丰富的配置选项而广受欢迎。通过精心配置 Nginx，我们可以充分发挥其潜力，提升网站或应用的响应速度和稳定性。</p><p>首先，我们需要关注 Nginx 的基本配置。在 Nginx 的配置文件中，我们可以看到诸如“worker_processes auto”和“sendfile on”等指令。这些指令分别用于设置工作进程数量和启用高效的文件传输方式，是 Nginx 性能优化的基础。</p><p>其次，优化并发连接数也是提升 Nginx 性能的关键。通过调整“worker_connections”指令的值，我们可以控制单个工作进程能够处理的最大并发连接数。根据服务器的实际负载和硬件资源，合理设置这个值，可以避免资源瓶颈和性能下降。</p><p>此外，Nginx 还提供了丰富的配置选项来优化特定场景下的性能。例如，通过配置“proxy_pass”指令，我们可以实现代理转发，将请求转发到其他服务器或应用。这对于负载均衡、缓存和静态资源服务等场景非常有用。</p><p>最后，我们还需要关注 Nginx 的安全配置。通过启用 SSL&#x2F;TLS 协议、配置访问控制和限制不必要的 HTTP 方法等方式，我们可以增强 Nginx 的安全性，保护网站和应用免受攻击和威胁。</p><p>综上所述，Nginx 的配置和优化是一个持续的过程，需要我们根据实际需求不断调整和优化。通过掌握 Nginx 的基本配置和优化技巧，我们可以更好地管理和提升 Web 服务器的性能，为用户提供更好的访问体验。</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 服务器优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cesium加载大数据量地下管线</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>TOC(Cesium 加载大数据地下管线)</p><h1 id="Cesium-优化加载"><a href="#Cesium-优化加载" class="headerlink" title="Cesium 优化加载"></a>Cesium 优化加载</h1><p>管线、管井、路灯、交通信号灯、接电箱等模型使用 Primitive 优化加载（数据量 20 万，包含排水管线流动方向）。</p><h2 id="管线加载"><a href="#管线加载" class="headerlink" title="管线加载"></a>管线加载</h2><p>Primitive 中利用 geometryInstances 几何集合方式进行数据成管模型加载思路：</p><ol><li>新建管线集合对象，利用 line_instances；</li><li>line_instances 添加 cesium 几何对象 GeometryInstance；</li><li>最后使用 Primitive 进行添加 line_instances 集合对象；<br><img src="https://image.imlzx.cn/blog/e59d9277b7ce5976a763c21e572e7526.png#pic_center" alt="管线图"><br>排水管空心管绘制,实心管绘制，方形空心管，方形实心管</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computeCircleFill</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  a = <span class="title class_">Number</span>(a) / <span class="number">1000</span>;</span><br><span class="line">  a = a / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> b = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(i);</span><br><span class="line">    b.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">Cartesian2</span>(a * <span class="title class_">Math</span>.<span class="title function_">cos</span>(c), a * <span class="title class_">Math</span>.<span class="title function_">sin</span>(c)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computeCircle</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  a = <span class="title class_">Number</span>(a) / <span class="number">1000</span>;</span><br><span class="line">  a = a / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> startAngle = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> endAngle = <span class="number">360</span>;</span><br><span class="line">  <span class="keyword">var</span> hd = a / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = startAngle; i &lt;= endAngle; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(i);</span><br><span class="line">    b.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">Cartesian2</span>(a * <span class="title class_">Math</span>.<span class="title function_">cos</span>(c), a * <span class="title class_">Math</span>.<span class="title function_">sin</span>(c)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = endAngle; i &gt;= startAngle; i--) &#123;</span><br><span class="line">    <span class="keyword">var</span> radians = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(i);</span><br><span class="line">    b.<span class="title function_">push</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">Cartesian2</span>(</span><br><span class="line">        (a - hd) * <span class="title class_">Math</span>.<span class="title function_">cos</span>(radians),</span><br><span class="line">        (a - hd) * <span class="title class_">Math</span>.<span class="title function_">sin</span>(radians)</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管井、摄像头、交通信号灯等模型加载"><a href="#管井、摄像头、交通信号灯等模型加载" class="headerlink" title="管井、摄像头、交通信号灯等模型加载"></a>管井、摄像头、交通信号灯等模型加载</h2><p>同样，我们使用 Primitive 的方式进行加载，新建模型集合对象 PrimitiveCollection，其次在使用 Primitive 集合进行添加即可。</p><h2 id="与倾斜摄影模型结合加载"><a href="#与倾斜摄影模型结合加载" class="headerlink" title="与倾斜摄影模型结合加载"></a>与倾斜摄影模型结合加载</h2><p>在加载管线的同时，我们亦可以加载倾斜摄影模型和白膜方式，进行可视化分析管理。<br><img src="https://image.imlzx.cn/blog/97854526b836a713710eaa78cb836943.png#pic_center" alt="倾斜摄影与管线结合图"><br>挖地分析<br><img src="https://image.imlzx.cn/blog/d383db03a789096c208c1ec44081ac33.png#pic_center" alt="挖地分析图"><br>了解更多：<a href="https://imlzx.cn/">神男码农</a></p>]]></content>
      
      
      <categories>
          
          <category> WebGis </category>
          
          <category> 前端 </category>
          
          <category> Cesium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cesium </tag>
            
            <tag> WebGis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>相册集</title>
      <link href="/album/index.html"/>
      <url>/album/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>幸运时刻</title>
      <link href="/dailyHappiness/index.html"/>
      <url>/dailyHappiness/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>炒股日常</title>
      <link href="/dailyStock/index.html"/>
      <url>/dailyStock/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>即刻短文</title>
      <link href="/essay/index.html"/>
      <url>/essay/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>日常生活</title>
      <link href="/dailyPhoto/index.html"/>
      <url>/dailyPhoto/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>朋友圈</title>
      <link href="/fcircle/index.html"/>
      <url>/fcircle/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>神男码农友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐馆</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>世界各地风景</title>
      <link href="/wordScenery/index.html"/>
      <url>/wordScenery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
